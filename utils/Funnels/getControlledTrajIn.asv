function [t1,Xk1,t,Xk,funIndx] = getControlledTrajIn(X0,iReg,kiter,funnelIn,funIndx,)

global Xk Uk K t

for k = 1:length(funnelIn{funIndx,iReg,2}.t)
    tmp = inv(funnelIn{funIndx,iReg,2}.P(:,:,k));
    tmp = (tmp+tmp')/2;
    E(k) = ellipsoid(funnelIn{funIndx,iReg,2}.x(k,:)',tmp*funnelIn{funIndx,iReg,2}.rho(k));
end
ellTmp1 = E;
Xk = funnelIn{funIndx,iReg,kiter}.x;
Uk = funnelIn{funIndx,iReg,kiter}.u;
K = funnelIn{funIndx,iReg,kiter}.K;
t = funnelIn{funIndx,iReg,kiter}.t;

clear nrm
for i = 1:size(Xk,1), nrm(i) = norm(X0' - Xk(i,:)); end
startIdx = min(find(min(nrm) == nrm), length(nrm)-1)
Xk(1:startIdx-1,:) = [];
Uk(1:startIdx-1,:) = [];
K(:,:,1:startIdx-1) = [];
t(1:startIdx-1) = [];
%         isinternal_quick(ellTmp1(1),X0)
switch modelType
    case 'unicycle'
        [t,Xk] = ode45(@ CreateKinematicsNLWayptCtrl1, t, initPoint);
    case 'car'
        [t,Xk] = ode45(@ CarKinematicsNLWayptCtrl1, t, initPoint);
end
[t1,Xk1] = ode45(@ CreateKinematicsNL, [0 10], X0);
% Wrap theta from -pi to pi
Xk1(:,3) = mod(Xk1(:,3)+pi,2*pi)-pi;
