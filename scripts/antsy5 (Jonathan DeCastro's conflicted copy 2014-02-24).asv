%
% ANSY - Atomic Nonlinear controller SYnthesis
%

% TODO:
% 1. Separate transition funnel generation into two parts to enforce
% containment by the critical reactive funnel
% 2. Make sure critical reactive funnels are not growing in 
% 2. Join/Reactive Join operations: check if constructed funnels are big
% enough to contain final set of the incoming funnel
% 3. Transition funnels are entering avoid regions by more than 0.1
% 4. Rare events where RRT doesn't obey dynamics
% 5. Better way of declaring RRT finished so that we end up with final
% point more inside the goal set (thus widening the join/reactive join
% funnels)

clear funnel funnelIn ellFunnel ellFunnelIn ellInit trans error

warning off

format compact
clear all
close all
global xyPath x debugFlg l

clear t Xk
ellFunnel = [];
ellFunnelIn = [];
funnel = [];
funnelIn = [];

% load antsy4_urbanDelivery_uni

% Model parameters
Hout = eye(2);

modelType = 'unicycle';

switch modelType
    
    case 'unicycle'
        f0 = @(t,x,u) CreateKinematicsPoly(t,x,u);
        n = 3;
        
        limsNonRegState = [-pi; pi];
        isCyclic = [0 0 1]';
        
        % LQR controller parameters
        S0 = 1e4*eye(n);   % Qf in terminal cost
        Q = @(t) 1e0*diag([100 100 0.0001]);
        % R = @(t) 1e2*eye(2);
        R = @(t) diag([1e4 1e2]);
        
    case 'car'
        f0 = @(t,x,u) CarKinematicsPoly(t,x,u);
        n = 4;
        
        limsNonRegState = [-pi -pi/2; pi pi/2]; % for a car-like robot
        isCyclic = [0 0 1 0]';
        
        % LQR controller parameters
        S0 = 1e4*eye(n);   % Qf in terminal cost
        Q = @(t) 1e0*diag([1000 1000 10 10]);
        % R = @(t) 1e2*eye(2);
        R = @(t) diag([1e3 1e2]);
end

debugFlg = false;

% Get map and transitions
threeRegionMap
% fourRegionMap
% urbanDelivery
% pursuerEvaderMap

Qrand = 2;

Ncover = 10000;
Nterm = 10;  % number of consecutive failures before coverage terminates
coverPct = 0.8;

Ntrans = length(aut.trans);
Nmodes = length(aut.q);

% Number of funnels/controllers for each state
maxFunnelsTrans(1:Nmodes) = 1;
maxFunnelsInward(1:Nmodes) = 5;

% Tree depth
depthTrans = 1;
depthInward = 1;

% Downsampling
sampSkipColl = 5;  % skipped samples in collision check -- higher value speed up collision checks but may miss parts of the trajectory
sampSkipFun = 10;  % skipped samples in funnel computation
sampSkipValid = 5;  % skipped samples in misbehavior check

maxFunTrials = 10;  % number of tries before giving up
maxTrials1 = 30; % set to a high value
maxTrials2 = 20;
maxTrials3 = 2;  % set to a low value because funFail takes care of final point interations.
maxNonRegTrials = 30;

% for state = 1:Ntrans
%     initState = getRandom(vReg{state},'discrep');
%     regPoint{state} = initState;
% end
% regPoint{state+1} = regPoint{1};  %close the loop

for imode = 1:Nmodes
    qReg = aut.q{imode};
    qCover{imode} = getCoverPts(vReg,{qReg},1,Ncover,Hout,n,limsNonRegState);
end

%%  Main

tic

plotWS(pReg)

for j = 1:Ntrans
    for i = 1:max(maxFunnelsTrans(aut.trans{j}(1)),size(funnel,1))
        funnel{i,j} = [];
        rhoMinArray{i,j} = [];
        ellFunnel{i,j} = [];
        trajFunnel{i,j} = [];
        IsectTrans{i,j} = [];
    end
end
for j = 1:Nmodes
    for i = 1:max(maxFunnelsInward(j),size(funnelIn,1))
        funnelIn{i,j} = [];
        rhoMinArrayIn{i,j} = [];
        ellFunnelIn{i,j} = [];
        trajFunnelIn{i,j} = [];
    end
end

%%
for iModeToPatch = 1:Nmodes
    %% Reach Operation
    reachOp
    
    %% Sequence Operation
    sequenceOp
    
end

save test

%%
joinedModes = false*ones(Nmodes,1);  % keep a list of modes which need joining
reactJoinedModes = false*ones(Nmodes,1);

for imode = 1:Nmodes
    patchedAndUnvistedModesToJoin = ~(joinedModes(1:imode) & reactJoinedModes(1:imode));
    
    for iJoinTry = 1:10  % max number of tries
        for iModeToJoin = find(patchedAndUnvistedModesToJoin)'  % recursively patch successor modes, if necessary
            disp(['... Attempting to join mode ',num2str(iModeToJoin)])
             %% Join Operation
            joinOp
            
            if joinedModes(iModeToJoin)
                disp(['... Successfully joined mode ',num2str(iModeToJoin),'. Now attempting to reactively join this mode.'])
                %% Reactive Join Operation
                for iReactTry = 1:10
                    reactivejoinOp
                    if reactJoinedModes(iModeToJoin), break, end
                end
            end
            
            if ~joinedModes(iModeToJoin) || ~reactJoinedModes(iModeToJoin)
                disp(['... Failed to join or reactively join mode ',num2str(iModeToJoin),'. Need to re-patch.'])
                break
            end
        end
        if ~joinedModes(imode) || ~reactJoinedModes(imode)            
            % update the list of modes which have already been joined but are affected by the patch and concatenate with the list of unvisited modes
            patchedAndUnvistedModesToJoin = find(~(joinedModes(iModeToJoin:imode) & reactJoinedModes(iModeToJoin:imode))) + (iModeToJoin-1);  % everything left on the todo list
            patchedAndUnvistedModesToJoin = [setdiff(transTmp(transTmp(:,1)==iModeToJoin,2),imode+1:Nmodes); patchedAndUnvistedModesToJoin];  % every successor to the current mode which had been joined
            if ~joinedModes(iModeToJoin) 
                patchedAndUnvistedModesToJoin = [setdiff(transTmp(transTmp(:,1)==iPreModeToJoin,2),imode+1:Nmodes); patchedAndUnvistedModesToJoin];
                patchedAndUnvistedModesToJoin = [setdiff(iPreModeToJoin,imode+1:Nmodes); patchedAndUnvistedModesToJoin];
            end    
            
            patchedAndUnvistedModesToJoin = unique(patchedAndUnvistedModesToJoin);
            patchedAndUnvistedModesToJoin
            joinedModes = [~ismember(1:imode,patchedAndUnvistedModesToJoin)'; joinedModes(imode+1:Nmodes)];
            reactJoinedModes = [~ismember(1:imode,patchedAndUnvistedModesToJoin)'; reactJoinedModes(imode+1:Nmodes)];
            
            %% Patch Operation
            disp(['... Patching the failed current mode (mode ',num2str(iModeToJoin),') ...'])
            iModeToPatch = iModeToJoin;
            reachOp
            sequenceOp
            
            if ~joinedModes(iModeToJoin)  % if join failed, also patch the pre mode
                disp(['... Also patching the pre-mode (mode ',num2str(iPreModeToJoin),') ...'])
                iModeToPatch = iPreModeToJoin;
                reachOp
                sequenceOp
            end
        end
        if all(joinedModes(1:imode) & reactJoinedModes(1:imode))
            break
        end
    end
end

%%
clk = fix(clock);
if strcmp(modelType,'unicycle')
    eval(['save antsy5_uni_',date,'_',num2str(clk(4)),num2str(clk(5)),num2str(clk(6))])
elseif strcmp(modelType,'car')
    eval(['save antsy5_car_',date,'_',num2str(clk(4)),num2str(clk(5)),num2str(clk(6))])
end

toc
